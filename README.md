# Compiler-project

## Overview

The compiler project solves the problem of translating high-level programming language code into low-level assembly code that can be executed on a Linux system. In short, this compiler project addresses the need for an automated, efficient, and reliable method to translate high-level programming languages into low-level assembly code, enabling the execution of complex programs on a Linux system. It also provides essential utilities for memory management, data structure handling, and command-line argument parsing, making the compiler robust and versatile.Here are the key problems it addresses:

1. **High-Level Language Translation:**
   - **Problem:** High-level languages are designed to be human-readable and abstract away the complexities of hardware and system calls. However, computers can only execute low-level machine code or assembly language.
   - **Solution:** The compiler translates high-level language constructs into assembly language, making the code executable by the CPU. This involves breaking down complex instructions into simpler operations that the hardware can understand.

2. **System Call Abstraction:**
   - **Problem:** Interacting with the operating system (e.g., for file operations, network communication) requires knowledge of specific system calls and their usage.
   - **Solution:** The project defines macros and constants for system calls and file operations in `linux.inc`, simplifying the process of making system calls and improving code readability and maintainability.

3. **Efficient Memory and Data Structure Management:**
   - **Problem:** Managing memory and data structures efficiently is crucial for performance and resource utilization in software development.
   - **Solution:** The project provides a utility library (`DS.H`) that includes implementations of dynamic arrays, priority queues, string builders, linked lists, hash tables, and more. These data structures are essential for various phases of compilation, such as storing tokens, managing symbol tables, and handling intermediate representations.

4. **Command-Line Argument Parsing:**
   - **Problem:** Parsing command-line arguments is a common requirement for many programs, but it can be error-prone and cumbersome to implement from scratch.
   - **Solution:** The project includes an argument parser utility in `DS.H`, which simplifies the process of defining and parsing command-line arguments, making it easier to configure and run the compiler with various options.

5. **Readability and Maintainability:**
   - **Problem:** Assembly language is verbose and difficult to read and maintain. High-level languages improve readability but need to be translated into a form that the machine can execute.
   - **Solution:** By providing macros and utility functions, the project abstracts many low-level details, making the assembly code generated by the compiler easier to read and maintain. This also reduces the potential for errors and improves the efficiency of the development process.

6. **Automation of Compilation Process:**
   - **Problem:** Manually converting high-level code to assembly language is time-consuming and error-prone.
   - **Solution:** The compiler automates the entire process of converting high-level language code to executable assembly code. This includes lexical analysis, parsing, and code generation, ensuring a consistent and reliable translation process.

### Project Overview
- **Components:**
  - **Lexical Analyzer (Lexer):** Tokenizes the source code into meaningful tokens.
  - **Parser:** Constructs an abstract syntax tree (AST) from tokens.
  - **Code Generator:** Translates the AST into assembly code.
  - **Utility Library (DS.H):** Provides essential data structures and utilities to support the compiler's functionality.
- **Execution Flow:**
  1. **Lexical Analysis:** Convert source code into tokens.
  2. **Parsing:** Build an AST from the tokens.
  3. **Code Generation:** Generate assembly code from the AST.
  4. **Compilation:** Output the generated assembly code.


## Template

```text
term = <input> | variable | literal
expression = term | term + term | ...
rel = term < term | ...
instr = variable = expression | <if> rel <then> instr | <goto> :label | <output> term | :label
```

Example of a program in this language

```text
n = input
i = 0
:label
output i
i = i + 1
if i < n then goto :label
if i < 10 then goto :label2
output 69
:label2
```

## Quickstart

```console
gcc -g main.c -o main
cat example.txt | ./main > example.asm
fasm example.asm
./example
```

## Functionalities

This compiler project is a comprehensive attempt to create a simple yet functional compiler for a custom programming language. Here’s an overview of the various files and their roles within the project:

### linux.inc
- **Purpose:** Contains constants and macros specific to Linux system calls and operations.
- **Content Highlights:**
  - Defines system call numbers (e.g., `SYS_read`, `SYS_write`).
  - Defines file operation constants (e.g., `O_RDONLY`, `O_WRONLY`).
  - Provides macros for making system calls (`syscall1`, `syscall2`, `syscall3`, etc.).

### utils.inc
- **Purpose:** Provides utility functions for common operations.
- **Content Highlights:**
  - Functions for writing integers and strings to files (`write_uint`, `write_cstr`).
  - String handling functions like `strlen`, `parse_uint`, `memcpy`, `find_char`, and `starts_with`.

### main.c
- **Purpose:** The main logic of the compiler, handling the overall process of lexical analysis, parsing, and code generation.
- **Content Highlights:**
  - **Lexical Analysis:** Functions for tokenizing the input source code (`lexer_next_token`, `lexer_read_char`, `lexer_peek_char`).
  - **Parsing:** Structures and functions to parse tokens into an abstract syntax tree (AST) (`parse_term`, `parse_expr`, `parse_rel`, `parse_instr`).
  - **Code Generation:** Functions to generate assembly code from the AST (`term_asm`, `expr_asm`, `rel_asm`, `instr_asm`).
  - **Main Function:** Reads source code, tokenizes it, parses it into an AST, and generates assembly code.

### DS.H
- **Purpose:** A single-header library providing a set of data structures and utilities to support the compiler’s implementation.
- **Content Highlights:**
  - **Dynamic Arrays:** Functions for managing dynamic arrays (`ds_dynamic_array_init`, `ds_dynamic_array_append`, `ds_dynamic_array_free`).
  - **Priority Queues:** Functions for managing priority queues (`ds_priority_queue_init`, `ds_priority_queue_insert`, `ds_priority_queue_pull`).
  - **String Builders:** Functions for building strings (`ds_string_builder_init`, `ds_string_builder_append`, `ds_string_builder_build`).
  - **String Slices:** Functions for handling substrings (`ds_string_slice_init`, `ds_string_slice_tokenize`, `ds_string_slice_to_owned`).
  - **Linked Lists:** Functions for managing linked lists (`ds_linked_list_init`, `ds_linked_list_push_back`, `ds_linked_list_pop_front`).
  - **Hash Tables:** Functions for managing hash tables (`ds_hash_table_init`, `ds_hash_table_insert`, `ds_hash_table_get`).
  - **Argument Parser:** Functions for parsing command-line arguments (`ds_argparse_parser_init`, `ds_argparse_add_argument`, `ds_argparse_parse`).
  - **IO Utilities:** Functions for reading and writing files (`ds_io_read_file`, `ds_io_write_file`).

